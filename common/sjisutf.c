/* Copyright (C) 2020 <KichikuouChrome@gmail.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
*/
#include "common.h"
#include "s2utbl.h"
#include <errno.h>
#include <stdlib.h>
#include <string.h>

static const uint8_t hankaku81[] = {
	0x20, 0xa4, 0xa1, 0x00, 0x00, 0xa5, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0xb0, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0xa2, 0xa3, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

static const uint8_t hankaku82[] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa7,
	0xb1, 0xa8, 0xb2, 0xa9, 0xb3, 0xaa, 0xb4, 0xab,
	0xb5, 0xb6, 0x00, 0xb7, 0x00, 0xb8, 0x00, 0xb9,
	0x00, 0xba, 0x00, 0xbb, 0x00, 0xbc, 0x00, 0xbd,
	0x00, 0xbe, 0x00, 0xbf, 0x00, 0xc0, 0x00, 0xc1,
	0x00, 0xaf, 0xc2, 0x00, 0xc3, 0x00, 0xc4, 0x00,
	0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0x00, 0x00,
	0xcb, 0x00, 0x00, 0xcc, 0x00, 0x00, 0xcd, 0x00,
	0x00, 0xce, 0x00, 0x00, 0xcf, 0xd0, 0xd1, 0xd2,
	0xd3, 0xac, 0xd4, 0xad, 0xd5, 0xae, 0xd6, 0xd7,
	0xd8, 0xd9, 0xda, 0xdb, 0x00, 0xdc, 0x00, 0x00,
	0xa6, 0xdd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

static const uint16_t kanatbl[] = {
	0x8140, 0x8142, 0x8175, 0x8176, 0x8141, 0x8145, 0x82f0, 0x829f,
	0x82a1, 0x82a3, 0x82a5, 0x82a7, 0x82e1, 0x82e3, 0x82e5, 0x82c1,
	0x815b, 0x82a0, 0x82a2, 0x82a4, 0x82a6, 0x82a8, 0x82a9, 0x82ab,
	0x82ad, 0x82af, 0x82b1, 0x82b3, 0x82b5, 0x82b7, 0x82b9, 0x82bb,
	0x82bd, 0x82bf, 0x82c2, 0x82c4, 0x82c6, 0x82c8, 0x82c9, 0x82ca,
	0x82cb, 0x82cc, 0x82cd, 0x82d0, 0x82d3, 0x82d6, 0x82d9, 0x82dc,
	0x82dd, 0x82de, 0x82df, 0x82e0, 0x82e2, 0x82e4, 0x82e6, 0x82e7,
	0x82e8, 0x82e9, 0x82ea, 0x82eb, 0x82ed, 0x82f1, 0x814a, 0x814b
};

// Unicode codepoints mapped from multiple SJIS codepoints.
static const uint16_t ambigious_unicodes[] = {
	0x2116,0x2121,0x2160,0x2161,0x2162,0x2163,0x2164,0x2165,
	0x2166,0x2167,0x2168,0x2169,0x2170,0x2171,0x2172,0x2173,
	0x2174,0x2175,0x2176,0x2177,0x2178,0x2179,0x221A,0x2220,
	0x2229,0x222A,0x222B,0x2235,0x2252,0x2261,0x22A5,0x3231,
	0x5022,0x5040,0x5042,0x5046,0x5070,0x5094,0x5164,0x5215,
	0x52AF,0x5300,0x5307,0x5324,0x5372,0x5393,0x5586,0x5759,
	0x5765,0x5953,0x5963,0x6085,0x6111,0x6120,0x6130,0x6137,
	0x6198,0x6213,0x6460,0x6600,0x6609,0x6615,0x6624,0x6631,
	0x6657,0x6659,0x6665,0x6673,0x6699,0x6766,0x6801,0x6844,
	0x6852,0x6968,0x6998,0x6D96,0x6DAC,0x6DCF,0x6DF2,0x6DF8,
	0x6DFC,0x6E27,0x6E39,0x6E3C,0x6E5C,0x6EBF,0x6F88,0x6FB5,
	0x6FF5,0x7005,0x7007,0x7028,0x7085,0x70AB,0x7104,0x710F,
	0x7146,0x7147,0x715C,0x71C1,0x71FE,0x72B1,0x72BE,0x7324,
	0x7377,0x73BD,0x73C9,0x73D2,0x73D6,0x73E3,0x73F5,0x7407,
	0x7426,0x7429,0x742A,0x742E,0x7462,0x7489,0x749F,0x7501,
	0x756F,0x7682,0x769B,0x769C,0x769E,0x76A6,0x7746,0x7821,
	0x784E,0x7864,0x787A,0x7930,0x7994,0x799B,0x7AD1,0x7AE7,
	0x7AEB,0x7B9E,0x7D48,0x7D5C,0x7DA0,0x7DB7,0x7DD6,0x7E52,
	0x7F47,0x7FA1,0x8301,0x8362,0x837F,0x83C7,0x83F6,0x8448,
	0x84B4,0x8553,0x8559,0x856B,0x85B0,0x8807,0x88F5,0x8A12,
	0x8A37,0x8A79,0x8AA7,0x8ABE,0x8ADF,0x8AF6,0x8B53,0x8B7F,
	0x8CF0,0x8CF4,0x8D12,0x8D76,0x8ECF,0x9067,0x90DE,0x9115,
	0x9127,0x91D7,0x91DA,0x91DE,0x91E4,0x91E5,0x91ED,0x91EE,
	0x9206,0x920A,0x9210,0x9239,0x923A,0x923C,0x9240,0x924E,
	0x9251,0x9259,0x9267,0x9277,0x9278,0x9288,0x92A7,0x92D0,
	0x92D3,0x92D5,0x92D7,0x92D9,0x92E0,0x92E7,0x92FB,0x92FF,
	0x9302,0x931D,0x931E,0x9321,0x9325,0x9348,0x9357,0x9370,
	0x93A4,0x93C6,0x93DE,0x93F8,0x9431,0x9445,0x9448,0x9592,
	0x969D,0x96AF,0x9733,0x973B,0x9743,0x974D,0x974F,0x9751,
	0x9755,0x9857,0x9865,0x9927,0x999E,0x9A4E,0x9AD9,0x9ADC,
	0x9B72,0x9B75,0x9B8F,0x9BB1,0x9BBB,0x9C00,0x9D6B,0x9D70,
	0x9E19,0x9ED1,0xF9DC,0xFA15,0xFA16,0xFA17,0xFA18,0xFA19,
	0xFA1A,0xFA1B,0xFA1C,0xFA1D,0xFA1E,0xFA1F,0xFA20,0xFA21,
	0xFA22,0xFA23,0xFA24,0xFA25,0xFA26,0xFA27,0xFA28,0xFA29,
	0xFA2A,0xFA2B,0xFA2C,0xFA2D,0xFFE2,
};

static int uint16_compare(const void *a, const void *b) {
	return *(const uint16_t *)a - *(const uint16_t *)b;
}

bool is_unicode_safe(uint8_t c1, uint8_t c2) {
	if (!is_sjis_byte1(c1) || !is_sjis_byte2(c2))
		return false;
	int cp = s2u[c1 - 0x80][c2 - 0x40];
	if (!cp)
		return false;
	if ((cp & 0xf000) == 0xe000)
		return false;  // Gaijis should be escaped
	const int nelem = sizeof(ambigious_unicodes) / sizeof(uint16_t);
	return !bsearch(&cp, ambigious_unicodes, nelem, sizeof(uint16_t), uint16_compare);
}

static int unicode_to_sjis(int u) {
	if (u < 128)
		return u;
	if (u > 0xffff)
		return 0;

	static uint16_t *u2s = NULL;
	if (!u2s) {
		// Create a reverse lookup table from s2u.
		u2s = calloc(0x10000, sizeof(uint16_t));
		for (int b1 = 0x81; b1 <= 0xfc; b1++) {
			if (b1 >= 0xa0 && b1 <= 0xdf)
				continue;
			for (int b2 = 0x40; b2 <= 0xfc; b2++) {
				uint16_t u = s2u[b1 - 0x80][b2 - 0x40];
				if (u && !u2s[u])
					u2s[u] = b1 << 8 | b2;
			}
		}
	}
	return u2s[u];
}

bool is_valid_sjis(uint8_t c1, uint8_t c2) {
	return is_sjis_byte1(c1) && is_sjis_byte2(c2) && s2u[c1 - 0x80][c2 - 0x40];
}

char *sjis2utf_sub(const char *str, int substitution_char) {
	const uint8_t *src = (uint8_t *)str;
	uint8_t *dst = malloc(strlen(str) * 3 + 1);
	uint8_t *dstp = dst;

	while (*src) {
		if (*src <= 0x7f) {
			*dstp++ = *src++;
			continue;
		}

		int c;
		if (*src >= 0xa0 && *src <= 0xdf) {
			c = 0xff60 + *src - 0xa0;
			src++;
		} else if (is_valid_sjis(src[0], src[1])) {
			c = s2u[src[0] - 0x80][src[1] - 0x40];
			src += 2;
		} else {
			if (substitution_char < 0)
				error("Invalid SJIS byte sequence %02x %02x", src[0], src[1]);
			c = substitution_char;
			src++;
		}

		if (c <= 0x7f) {
			*dstp++ = c;
		} else if (c <= 0x7ff) {
			*dstp++ = 0xc0 | c >> 6;
			*dstp++ = 0x80 | (c & 0x3f);
		} else {
			*dstp++ = 0xe0 | c >> 12;
			*dstp++ = 0x80 | (c >> 6 & 0x3f);
			*dstp++ = 0x80 | (c & 0x3f);
		}
	}
	*dstp = '\0';
	return (char *)dst;
}

char *utf2sjis_sub(const char *str, int substitution_char) {
	const uint8_t *src = (uint8_t *)str;
	uint8_t *dst = malloc(strlen(str) + 1);
	uint8_t *dstp = dst;

	while (*src) {
		if (*src <= 0x7f) {
			*dstp++ = *src++;
			continue;
		}

		int u;
		if (*src <= 0xdf) {
			u = (src[0] & 0x1f) << 6 | (src[1] & 0x3f);
			src += 2;
		} else if (*src <= 0xef) {
			u = (src[0] & 0xf) << 12 | (src[1] & 0x3f) << 6 | (src[2] & 0x3f);
			src += 3;
		} else {
			if (substitution_char < 0)
				error("Unsupported UTF-8 sequence");
			*dstp++ = substitution_char;
			do src++; while ((*src & 0xc0) == 0x80);
			continue;
		}

		if (u > 0xff60 && u <= 0xff9f) {
			*dstp++ = u - 0xff60 + 0xa0;
		} else {
			int c = unicode_to_sjis(u);
			if (c) {
				*dstp++ = c >> 8;
				*dstp++ = c & 0xff;
			} else {
				if (substitution_char < 0)
					error("Codepoint U+%04X cannot be converted to Shift_JIS", u);
				*dstp++ = substitution_char;
			}
		}
	}
	*dstp = '\0';
	return (char*)dst;
}

uint8_t compact_sjis(uint8_t c1, uint8_t c2) {
	return c1 == 0x81 ? hankaku81[c2 - 0x40] :
		   c1 == 0x82 ? hankaku82[c2 - 0x40] : 0;
}

uint16_t expand_sjis(uint8_t c) {
	if (!is_compacted_sjis(c))
		return 0;
	if (c == ' ')
		return 0x8140; // full-width space
	return kanatbl[c - 0xa0];
}
